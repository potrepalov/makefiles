Компиляция программы.


Для компиляции программы используется утилита GNU make
(https://www.gnu.org/software/make/manual/make.html).

В процессе компиляции, помимо компиляторов и линковщика, также используются
ряд вспомогательных утилит:
 -- GNU sed (https://www.gnu.org/software/sed/manual/sed.html);
 -- утилиты из пакета GNU Coreutils: mkdir, cp, mv, rm
    (https://www.gnu.org/software/coreutils/manual/coreutils.html).

Процесс компиляции определяется файлами:
 -- Makefile;
 -- files.mk;
 -- makef.mk;
 -- rules.mk.

Файлы Makefile, makef.mk и rules.mk должны находиться в одном каталоге.
В каждом каталоге с исходными текстами может быть свой, уникальный
для данного каталога, файл files.mk; т.е. файлов files.mk в проекте
может быть несколько. Утилита make должна запускаться в том каталоге,
в котором находится файл Makefile.



rules.mk

В этом файле задаются правила компиляции для различных платформ
(AVR, ARM, AVR32 и т.п.): способ вызова компилятора и обязательные
для платформы флаги компиляции, правила получения объектных файлов
из исходных, правила линковки объектных файлов и т.д.  Выбор
конкретной платформы выполняется на основе значения переменной
MCU_TARGET.



files.mk

В этом файле перечисляются файлы с исходными текстами программы.
Для перечисления файлов с текстом на определённом языке программирования
используются следующие переменные:
 -- для перечисления файлов с текстом программы на языке C предназначена
    переменная C_SRC;
 -- на языке ассемблера -- AS_SRC;
 -- на языке C++ -- CPP_SRC.

Например:

C_SRC := main.c one.c
C_SRC += two.c
AS_SRC := isr.S

Для других языков программирования можно использовать аналогичные переменные,
заканчивающиеся на _SRC.

Правила обработки исходных файлов из каждого списка задаются в файле rules.mk
(сейчас задаются правила только для трёх указанных языков программирования).

В этом же файле (files.mk) задаются флаги компиляции файлов из данного
каталога.  Для этого предназначены переменные CFLAGS, ASFLAGS и т.д.
Кроме того, для каждого файла можно задать уникальные флаги компиляции;
например, для файла two.c:

two.c := --std=gnu99 -O3




makef.mk

Вспомогательный файл, позволяющий организовывать вложенность файлов files.mk.

Для того, чтобы обработать файл files.mk из другого каталога (не обязательно
вложенного), в файле files.mk текущего каталога необходимо добавить присвоение
переменной SRCDIR относительного имени каталога с файлом files.mk и включить
файл makef.mk.  Например, следующие строки в файле ./src/files.mk:

SRCDIR := sub-src
include makef.mk

SRCDIR := ../super-puper-src
include makef.mk

вызовут обработку файлов ./src/sub-src/files.mk
и ./src/../super-puper-src/files.mk (или ./super-puper-src/files.mk).

В каждом из этих файлов можно заново определять переменные C_SRC, AS_SRC
и прочие.

Рекурсивная вложенность файлов files.mk никак не отслеживается
и не должна использоваться.



Makefile

Это головной файл, который обрабатывает утилита make.

Здесь указывается цель по умолчанию для утилиты make, имя программы,
флаги компиляции, линковки и прочая уникальная для программы информация.
Здесь же можно определять переменные со списками файлов исходных
текстов программы или обрабатывать файлы files.mk из разных каталогов
(с помощью файла makef.mk).

Правила для утилиты make составлены таким образом, что при изменении
файлов Makefile и files.mk будут перекомпилированы только те файлы исходных
текстов программы, которых эти изменения могут коснуться.



Для чего всё это сделано.

Готовые модули программ, оформленные как библиотеки, для микроконтроллеров (МК)
разрабатываются и поставляются, чаще всего, в виде исходных текстов
(т.к. вариантов компиляции для МК очень много и учесть их все для поставки
библиотеки в объектных файлах практически невозможно).  При добавлении
в программу такой библиотеки хотелось бы абстрагироваться от её состава
и необходимых ей специфичных правил компиляции.  Традиционно это решается
оформлением отдельного файла Makefile для библиотеки.  Но, как показано
в статье "Recursive Make Considered Harmful"
(http://aegis.sourceforge.net/auug97.pdf), это может вызывать ошибки.

Описываемая система позволяет включать библиотеку функций в виде исходных
текстов и не отслеживать изменения в её составе: в основной программе
достаточно ограничится включением обработки файла files.mk библиотеки.
Возможные дальнейшие изменения в составе библиотеки и правилах её компиляции
должны отражаться в соответствующем файле files.mk и не будут вызывать
никаких изменений в правилах компиляции основной программы.  Именно
для достижения этой цели была создана данная система компиляции программ.





						Потрепалов И.С.
						Октябрь 2014 г.
